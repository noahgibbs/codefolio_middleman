---
title: "Why Don't Software Developers Do More Coding Exercises?"
featured_asset: bad_practice
featured_caption: "I'm sure this exercise works fine. I've seen highly-skilled players with this equipment before."
---

Coding exercises seem like a great idea if you want to learn coding. If you want to learn a practical skill then you should practice, right?

And yet early coders don't do a lot of them. Some, but not a lot. And the longer you've been a coder, the fewer of them you seem to do. Ask your favourite long-term veteran coder. A few of them will act guilty that they don't, but almost none of them actually do coding exercises.

Why?

I could rail about how silly that is. But I won't. If nearly everybody doesn't do something, it's usually because it's not as good an idea as it seems.

In this case, the majority view is, basically, correct. But there's a better alternative that a few people do, especially long-time coders. ***That's*** what you should ***actually*** be doing. Let's talk about that.

READMORE

## What Are These Exercises That Don't Work?

There are many kinds of coding exercises, both common and uncommon. I'll start with "common" and move toward "more effective."

### Algorithm Challenges

The most common coding exercises are what I call "algorithm of the week" exercises. They describe a simple problem, usually about maths or data structures, and you have to find an effective algorithm to solve it, then code that. Here are some classic examples:

"You have a list where each element links to the next element. But if it links back into the same list, it could have a cycle, and so it could be infinitely long. How can you tell if the list I've handed you has a cycle or not?" ([example solutions](https://www.geeksforgeeks.org/detect-loop-in-a-linked-list/))

"Inside every string there is at least one palindrome (words that are the same if you reverse them.) In fact, every individual letter is, technically a palindrome. But how can you find the length of the longest palindrome inside a given string?" ([analysis on Wikipedia](https://en.wikipedia.org/wiki/Longest_palindromic_substring))

These are an effective way to practice one very specific subskill of software development: coming up with an algorithm for an unfamiliar data-structures problem. When people criticise these exercises (and [that happens a lot](https://danluu.com/algorithms-interviews/),) they criticise them because that subskill isn't very much of what software developers actually do, day-to-day.

But not only do we not do that very much, it's often a bad idea to do too much. People who are obsessed with the algorithms with the best [asymptotic complexity](https://en.wikipedia.org/wiki/Big_O_notation) often ignore the real-world math about the normal size of the data that will really happen. They also tend to ignore a lot of other important factors when treating a real-world application (full of human behaviour) as if it were an oversimplified math problem.

That's not to say that algorithms problems, asymptotic complexity and analysis are bad. They aren't. But you have to avoid treating them as the whole problem &mdash; they're just one small aspect of it.

So algorithm challenges like this can be useful, but their usefulness is limited and specific. Once you get good at this skill, you'll find you don't need a lot more practice at it.

In their favour, though, these are easy to find. You can join a challenge/exercise site (e.g. TopCoder or exercism.io) and they'll give you as many of these as you could ever want, immediately and for free. The quality of exercises may vary, of course, and you won't really know until you've worked through them.

Can you "over-practice" these with a bad real-world result? Absolutely. Software shops often tell you to be careful about interview candidates with a high rating on TopCoder or similar challenge sites because they tend to ***absolutely rock*** the job interviews, and then do poorly after you hire them. They do poorly because they treat real-world problems like algorithm challenges, and the results don't work well when you're trying to solve real problems for real users and get paid to do it. Algorithmic complexity isn't everything in the real world.

### 



### Code Katas

[Code Katas](http://codekata.com/) are a specific kind of coding exercise described by Dave Thomas of [Pragmatic Programmers](https://pragprog.com/) fame.

I don't meet many people who do them regularly, but they're ***great exercises*** if done well. They don't even necessarily involve coding ([example](http://codekata.com/kata/kata01-supermarket-pricing/)) and are mostly design exercises. I don't think coders do enough of that, and I respect how Code Katas present it.

In their favour, they're about turning an interesting real-world problem into a set of assumptions and algorithmic steps. That ***is*** what a coding job involved day-to-day and it's great practice we don't get enough of.

Against them, they're mostly a set of pre-worked examples. It's not necessarily clear how you would set up your own Code Katas after you finish the 21 of them that Dave put together, or use them to learn deeper skills once you get past his initial choices.

So they're good exercises. But if you want more or different Code Katas, you'd have to go ask Dave.

### Project-Based Books

There are some examples out there of building nontrivial learning projects from a book. There are also series of blog posts that do a similar trick. I'm thinking of books like "99 Bottles of OOP" by Sandi Metz, or Peter Shirley's "Build a Raytracer in One Weekend."

They have a lot of good points: the best of them are amazing and you can learn a lot more from a large project than a tiny one-off exercise. If the writer/instructor is good then you can get a lot of feedback on what you're doing well and poorly. The project is often interesting and it may even be useful when you're done.

They also have some bad points. First, you'll need to find them. In my experience the best of these are rare and already famous. The problem isn't finding [99 Bottles of OOP](https://www.sandimetz.com/99bottles) or [The Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html). The problem is that once you've worked through it, what's next? And since they're rare, there may not be one that teaches the skill you want. 99 Bottles teaches TDD and Refactoring. But what's the book for practicing closures or recursion as a real-world project? It's not clear that there is one, though obviously there are some good books that teach those skills. But if you want a ***practical exercise*** to learn to use a given skill in the real world, the book or project you're looking for may not exist.

### Independent Projects



## What Do Old-Timers Do Instead?

## How Can I Do It Right?




[my RubyConf talk](https://www.youtube.com/watch?v=33fAzjOTaDE)
