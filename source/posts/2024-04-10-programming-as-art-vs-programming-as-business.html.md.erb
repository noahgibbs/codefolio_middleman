---
title: "Programming as Art, Not Business"
tags: career, business, ruby, favorite
featured_asset: how_to_solve_it
featured_caption: "A Little Light Reading"
---

Awhile back I wrote [The Forty-Year Programmer](https://codefol.io/posts/the-forty-year-programmer/). You can think of it as my declaration of programming as art, not business. It's about taking your time and getting good gradually over many years, which works great for art, but often badly for your career.

Today I want to talk about the differences between programming-as-art and programming-as-business.

READMORE

## Bland and Forgettable

Over and over I say, "programming is great work, and it's an okay job".

Here's the thing: programming ***is*** art. It's a kind of art where the final product is a behaviour, not a visible or material object. So in some ways it's massively different from writing, but in others it's exactly the same.

That doesn't mean it's all ***good*** art, obviously. But a programmer is modelling the world and expressing something. Programming is one specific artistic medium.

Art usually sucks when you do it for business' sake. We remember a lot of art done for its own sake, like Renaissance paintings. We remember a certain amount of exceptional commercial art, like the song Rudolph the Red-Nosed Reindeer -- based on an advertisement! But mostly, commercial art is bland and forgettable.

You'll also see art where we try to avoid that. Movies, music albums, book covers drawn by famous illustrators and so on centre the artists and their visions. Sometimes something decent comes through. Sometimes not.

But a random commercial's cinematography is usually nothing to write home about. Or its music. A brochure design is rarely done with intention, skill and initiative. Mostly they're trying to be pretty and forgettable.

Bland.

Programming is mostly done for money. And it's mostly bland and forgettable.

You'll see exceptions, where code-for-money is still good, and still has a real opinion or two, just like with advertising jingles and brochure designs. That's just not the way to bet.

The design is also often bland, but that's not what I mean. The behaviour -- the programming -- is generally bland as well. We use the libraries other people use. We do "boring programming" not just where we're not doing anything new, but where it would be ***useful*** do something new.

If you're not hiring artists, and you don't want to, doing something new is bad. If you have a tool that pretty much gets the job done, you use it, and you pretty much get the job done.

Is that a criticism? Meh, it depends. But it's the exact opposite of programming for its own sake. It's also the exact opposite of seeing what ***could*** be done.

## Bad At It

There's very little money in playing piano. Almost any other way of making money is easier. That's partly for lack of demand. It's hard to charge a ton of money for music. It's also because the supply of good musicians is so strong.

You can get absolutely world-class piano instruction for very cheap. Sometimes even for free. With the rise of YouTube we're seeing an unprecedented number of amazing young piano prodigies, which should tell you that the instruction is quite good.

Programming pays a lot because doing it is unpleasant for most people. It also pays a lot because you can charge a lot for software. And it pays a lot because the instruction is terrible. It's genuinely hard to learn, and the available instruction is bad.

It's not all our fault. There have only been programmers since the 1950s or so, and most of us make terrible teachers. [The rare exceptions](https://en.wikipedia.org/wiki/Seymour_Papert) are legendary, but still rare. As a result, all our tools and environments are gratuitously awful. They're designed by non-teachers, and are mostly hard to teach and learn. The [rare chances](https://sandimetz.com/99bottles) to [see counterexamples](https://worrydream.com/LadderOfAbstraction/) remind us how bad the day-to-day is.

There's joy in programming once you know what you're doing. At least, there is for me and for some others like me. But it's not a field that's going to meet you halfway.

Maybe some day the tools and teaching will be so good that learning programming is merely intimidating, like how composing music is intimidating. Instead, it's intimidating like how composing music *used* to be intimidating, where it was considered a weakness to need a piano instead of hearing all the notes in your head.

Maybe programming is just too hard to teach like anything else? Nah. There were some good teachers, back when people like Seymour Papert were teaching things like LOGO. You didn't really even need a computer to do that -- LOGO works fine with a few kids and some paper. [Scratch](https://scratch.mit.edu) isn't nearly as hard to start teaching, and it uses Smalltalk under the hood. It ***is*** a real language and a good way to learn programming.

Instead, mostly we pick things that are painful, hard to learn and hard to teach, because they're the shortest distance to getting a job in programming.

Maybe that's fine? It definitely is if you assume programming isn't a worthy art, and getting a paycheck is the only acceptable purpose for it.

You could argue against my musicians analogy. Music is a big industry. But how much of that goes to musicians? If you treat really successful musicians like Taylor Swift or Beyonce as having two jobs -- being a musician and running a media empire -- then one of those two jobs pays thousands of times more than the other. Being a musician can be very profitable in the rare cases where it enables a slight extra advantage on top of something already very profitable.

Mostly, being a musician pays lower-than-survival wages. That's pretty typical for work that feels meaningful in and of itself, especially if it doesn't also make somebody else a ton of money.

## Cutthroat and Competitive

You'll sometimes hear people talk about win-win scenarios, and how software raises all boats. And some of that is true. For instance, sharing your knowledge by teaching or by writing open-source software ***does*** make everybody better at software, faster.

For programming-as-art, it's a great idea.

But programming-as-a-job is uglier that way. You have a fairly fixed number of jobs being handed out. Making everybody better makes the competition fiercer. It's pretty close to [zero-sum](https://en.wikipedia.org/wiki/Zero-sum_game), where helping one person hurts everybody else about as much.

(Certain folks, especially consultants, would argue that this is all positive-sum, and more confident and capable job seekers increase the size of the industry and everything just gets better faster. Maybe? But businesses act as though it's not true, limiting the benefit to random people. The benefit, if any, seems ***much*** smaller than for programming-as-art.)

I feel proud of teaching programming, especially when I [think I've done a good job](https://rebuilding-rails.com). I feel a lot more mixed about offering career advice. That's a straight-up competition between you and the other hopefuls trying to get the same job. I don't mind helping you, but I feel mixed about hurting everybody else.

## Money and Art Don't Get On

Programming instruction has another strike against it: the students are mostly there to get a job.

You've seen the constant complaint that universities don't teach the skills industry currently want. This is true.

If you wanted to learn programming as art, you'd want to know the timeless skills. I promise, they exist, even in programming.

But "timeless skills" in programming are like timeless skills in other art medium. That's not what gets you the job.

You might have a fantastic sense of composition, honed by composing Swiss-style minimalist posters of text. But the company would like somebody who can airbrush a shiny-smooth picture of an anime girl with gigantic... eyes.

Programming has a lot of similar situations. Yes, yes, the lambda calculus can teach you a deeper understanding of modularity, but that's not what we build web apps in. Sure, C can tell you some interesting architectural stuff about how computers work, but we're building a free iOS app to scam parents with in-app purchases.

If I were advising a young programmer who genuinely loved programming as expression and art, I could tell her about the work, and I could tell her about the job, but it would be hard to forge a middle path between those two.

It's getting harder, year by year.

## The Old Path

Silicon Valley companies used to be about making something impossible, possible. Spreadsheets do a thing you couldn't do before spreadsheets. They made vast quantities of repetitive math workable. If you put together a professional workstation to use your computer for a job, every program has a predecessor that first made a thing possible back in the dawn days.

Art workstation? Needs various drawing and illustrating programs. You could argue about what was the first one, but if you think of Photoshop as the grandpa you're not far off. There were a lot of companies that made programs to do things which, at first, computers -- and people -- couldn't do. And then afterward, computers ***could*** do those things.

Music workstation? Needs a DAW. Also a variety of audio converters, filters and so on. Now software companies fine-tune those things. Once, software companies made new things that didn't exist yet.

Computer lathe? Needs CAD programs to design the shape it's cutting out. Those, too, had origin stories.

There are similar enabling programs for hardware design and accounting and medical data entry and many, many other jobs. Didn't exist, then did exist.

And once upon a time, Silicon Valley was about creating new programs to make new things possible. At least up through Google, you could argue that was true.

These days a Silicon Valley company is making a smoother, easier to use version of something that already exists and finding a better way to market it. The days of "make something new possible" are mostly over, and have been for years. Every so often it happens. But mostly companies say they're doing that, but they're transparently lying.

Here's why you care: as an artist, a business who's creating something new needs you more. A business that's tweaking how they sell an old thing needs you less.

Programmers used to thread the needle between good art and good business because software businesses needed really good software artists. They don't any more.

You can tell in a lot of ways. Open-plan offices, which are ***much*** worse for doing work have been standard for a long time because they're lower rent. Remote work tools are better than ever but here we are returning to the office. The best programmers can do things that most programmers can't, even if you hire ten times as many. But it's seriously rare to see even a great programmer paid three times what a beginner gets.

Corporations thrive by making people cheap and easily replaceable. That's not just true in software. It's true everywhere. And they've been working at it for centuries. They're genuinely good at it at this point. Businesses don't require amazing software engineers, because it's more profitable and stable to build a business that doesn't ***need*** amazing people so you don't have to find or retain them.

Getting the very best programmers used to be a matter of tech-startup survival. It's just not any more.

And that means if you want to be a really good software artist, the business doesn't much care any more.

The old way doesn't help you much. Not these days.

## Two Paths Diverged

Can you just do programming as art? Sure. You'll be out of step, but artists often are.

If you write about [how to do that](https://codefol.io/posts/the-forty-year-programmer/) people won't understand. When I say that you can keep programming decade after decade, folks reply "no you can't" because companies won't hire you.

If you're doing it as art, you actually don't care if companies hire you.

You have to figure out what you're doing for money, of course. But nobody will tell you you can't play piano because you have to eat. It's just understood that you'll have a day job -- and that's the ***easy*** way to do it.

I used to hear a lot of recommendations that you do programming as your day job and do hobby stuff on your own. You'll still hear that. It's fine. Just keep in mind that programming for business tends to dominate all dialogue about programming, everywhere.

If you program for love, businesspeople will show up and tell you that you have to do it for them. Everything needs to be enterprise-friendly. Everything has to be sufficiently security conscious that banks can use it.

You *can* be out of step with that. But you can figure out a lot about how tolerated programming as art is, by watching how other programmers respond to you doing that.

Keep in mind that you're on a weird path and people won't even understand what you're talking about.

Which, again, is very traditional for artists. But keep it in mind.

## But Maybe It Isn't Art?

One popular rebuttal to all of this goes: yeah, but programming isn't art.

I used to be annoyed by that response. I'm more entertained these days since I know a little more history. Novels, comics, games have all faced the same exact criticism, which was nonsensical for all of them, too.

Computer programs are routinely used to make art - the behaviour of the program can light up LEDs or otherwise make visible or audible patterns, or words. That combination is clearly, without question, art.

"Yeah, but the ***code*** isn't art, you just hooked it up to something that made art."

No. That's like saying digital art isn't art because the monitor phosphors make art. Not even a little. The ***interesting and intentional pattern made by a human*** is the art. Frequently that pattern lives in data and signal -- like with recorded music -- not necessarily in a physical object.

Ebooks are writing, and thus art. Digital painting is painting, and thus art. The behaviour of the computer program is art.

It can still be awful art, of course. "The cat sat on the mat" is a poem, it's just not a very good one.

## Changing the World

Back in the Silicon Valley days there was a lot of talk about changing the world through companies and through programming. That line is getting less common as people realise what corporate programming is actually doing to the world. Cryptocurrency, artificial intelligence, [addictive Skinner-box design](https://www.youtube.com/watch?v=tWtvrPTbQ_c), climate change and so on look really bad, and they keep looking worse. The tech industry seems as hell-bent on world destruction as most other industries. As with fossil fuels and tobacco, I don't think we'll be remembered fondly.

But you ***can*** still change the world by art, and by love, the same as always. And sometimes programming can help.

The thing is, getting really good at something isn't necessarily profitable. Changing the world for the better isn't usually profitable. Companies do not, historically, pay you to do those things.

Programming-as-art is almost certainly headed the same way as playing piano: a thing that's intrinsically rewarding, but not terribly profitable. Don't worry - the miserable kind of programming mediocre stuff will still pay well for quite awhile yet.

It used to be that we didn't have to worry if we were teaching programming-as-art or not. You could learn the same way as for business and make money doing it. It looks like those days are slowly coming to an end. The kind of satisfying, skilled, difficult programming that you'd do for your own improvement and enjoyment is less and less what businesses need, want or tolerate.

So how do you get really good if you want to for your own sake?

I have more to say on that topic. I've said a lot already. [There's a specific kind of practice that helps a lot](https://www.youtube.com/watch?v=33fAzjOTaDE).

But step one is simpler: understand that you're no longer in alignment with what the business wants.

If you're a fantastic, hard-to-replace programmer then you're hard to replace. That's bad from the business's point of view. It's also the entire reason for art -- if every artist was interchangeable, why would we care what they had to say?
