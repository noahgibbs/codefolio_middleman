---
title: "Ruby and the Future of Programming"
tags: career, business, ruby, rails, favorite
featured_asset: professor
featured_caption: "Is Ruby the Future of Programming? Experts weigh in..."
---

On Mastodon, [FullStack Ruby asks](https://ruby.social/@fullstackruby/109558447163489186):

<hr/>

It's a strange sort of environment to be living in as a Ruby programmer.

On the one hand, so much momentum behind low-level "systems" programming languages with strong, static typing.

On the other hand, the "future of programming" is guiding the education of machine learning models, or whatever.

<b>QUESTION</b>: What's the future of expressive, dynamic languages with great reflection, metaprogramming, and DSL creation abilities? Why can't *that* be the future of programming? üòµ‚Äçüí´

Inquiring minds‚Ä¶

<hr/>

It's a great question. Rust ***does*** have a lot of momentum with its great sales pitch of "systems programming, without the risk of seg faults and memory errors." Machine learning, with things like CoPilot and ChatGPT, is a different future being promised, and also massively hot and hyped.

So where is there room for Ruby?

Here's what I wrote.

<hr/>

I feel like Ruby is an approach to expressiveness in programming. As far as what we are to the future of programming, we're more in the category of Scratch, or spreadsheets, or even some language-verification tools.

We're not trying to push the machine to its performance limits -- mostly uninterested in that question. We're pushing *expressiveness* as hard as possible, which improves the experience of authoring, and who can do it.

There's a future there, but it's farther off.

I see some writing about *that* future, but it's often folks like [Bret Victor](http://worrydream.com/) or [Nicky Case](https://ncase.me/) talking about forming mental models and bringing code-like interactivity into how you communicate around a problem.

Bret's not using Ruby, but I definitely find a lot of common ground with his essays like [Up and Down the Ladder of Abstraction](http://worrydream.com/LadderOfAbstraction/).

And as with all "future of programming" stuff, it's important to understand that Ruby can't be the final form.

I have some thoughts about things that should be true about the final form, and some of them basically exclude Ruby... But we should expect that, right? Ruby is *old*. Just as you can't easily adapt C to match Rust's safety guarantees, when we (finally, eventually) get languages with some of the characteristics we'll need for great long-term authoring and expressiveness, it'll need features ***nobody*** currently has.

Partly we just need to remember that [programming is young](https://codefol.io/posts/the-forty-year-programmer/). I've been a programmer for more than half of the time there have been programmers. There are people still working in the field who date back to basically the beginning.

Things are still changing fast. Changes to expressiveness move at human speeds. How many thousand years did broad literacy take to spread?

It's early days yet for interactive artefacts of expressiveness.

At the risk of quoting Bret again, [***here*** is what noodling about *that* future looks like](https://www.youtube.com/watch?v=agOdP2Bmieg). I'll be shocked if it's in good shape in less than fifty years, and two hundred is more likely. 

When you [ask about "momentum" about being the future of programming, you're talking short-term trends](https://codefol.io/posts/what-do-they-mean-when-they-ask-if-rails-is-dead/) -- whether we think of the future as The Jetsons or Brazil or whatever.

Most of what Ruby is amazing at is long-term stuff. Rails was a great example, and I don't think it'll be the last. But those don't show up every 3-5 years and sustain a hype cycle.
